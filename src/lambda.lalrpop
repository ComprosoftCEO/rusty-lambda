use crate::symbol_table::*;
use crate::expr::*;

#[LALR]
grammar<'assign, 'eval>(sym: &mut SymbolTable<'assign, 'eval>)
where
  'input: 'assign,
  'assign: 'eval;

match {
  r"\s*" => { },               // Skip normal whitespace
  r";[^\n\r]*[\n\r]*" => { },  // Skip `; comments`
  _
}

pub Program: () = {
  Statement* => { () },
}

pub Statement: Option<ExprRef<'eval>> = {
  <o:@L> <i:Identifier> "=" <e:AssignExpression> => { 
    sym.declare_global(i, e, o.into());
    None
  },
  <e:EvalExpression> => Some(e),
}

AssignExpression: ExprRef<'assign> = {
  "(" <AssignExpression> ")",
  <o:@L> <t:Identifier> => sym.build_assign_term(t, o.into()),
  "\\" <is:AssignLambdaIdentifier+> "." <e:AssignExpression> => sym.build_assign_lambda(is, e),
  "(" <l:AssignExpression> <rs:AssignExpression+> ")" => sym.build_assign_eval(l, rs),
  // Number => { () },
}

AssignLambdaIdentifier: &'input str = {
  <o:@L> <i:Identifier> => {
    sym.start_assign_lambda(i, o.into());
    i
  },
}

EvalExpression: ExprRef<'eval> = {
  "(" <EvalExpression> ")",
  <o:@L> <t:Identifier> => sym.build_eval_term(t, o.into()),
  "\\" <is:EvalLambdaIdentifier+> "." <e:EvalExpression> => sym.build_eval_lambda(is, e),
  "(" <l:EvalExpression> <rs:EvalExpression+> ")" => sym.build_eval_eval(l, rs),
  // Number => { () },
}

EvalLambdaIdentifier: &'input str = {
  <o:@L> <i:Identifier> => {
    sym.start_eval_lambda(i, o.into());
    i
  },
}

// Any unicode character except semicolon ; which is used for comments
Identifier: &'input str = {
  r"[!-/:<-~\xA0-\u{10FFFF}&&\S][!-:<-~\xA0-\u{10FFFF}&&\S]*",
}

// Sequence of digits with possible underscores
Number: u64 = {
  r"[0-9][0-9_]*" => parse_integer_literal::<u64>(<>).expect("invalid integer"),
}

// ===========================
//       Template Types
// ===========================
CommaStar<T>: Vec<T> = DelimStar<T, ",">;
CommaPlus<T>: Vec<T> = DelimPlus<T, ",">;

// Every line must end with a semicolon
SemiLinesStar<T>: Vec<T> = <(<T> ";")*>;

// Trailing not allowed
CommaPlusNoTrailing<T>: Vec<T> = DelimPlusNoTrailing<T, ",">;

DelimStar<T, D>: Vec<T> = {
  <v:(<T> D)*> <e:T?> => {
    let mut v = v;
    if let Some(e) = e { v.push(e); }
    v
  },
};

DelimPlus<T, D>: Vec<T> = {
  <v:(<T> D)*> <e:T> <c:(",")?> => {
    let mut v = v;
    v.push(e);
    v
  },
}

DelimStarNoTrailing<T, D>: Vec<T> = {
  () => vec![],
  <e:T> => vec![e],
  <v:(<T> D)*> <e:T> => {
    let mut v = v;
    if let Some(e) = e { v.push(e); }
    v
  },
}

DelimPlusNoTrailing<T, D>: Vec<T> = {
  <v:(<T> D)*> <e:T> => {
    let mut v = v;
    v.push(e);
    v
  },
}
